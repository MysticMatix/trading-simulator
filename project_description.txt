Project Name: Algorithmic Trading Simulator

Description: This project aims to create a basic algorithmic trading simulator that uses historical market data to simulate trades based on a defined strategy. The project is designed with a focus on object-oriented programming principles and a modular structure to ensure scalability and maintainability.

File Structure:

1. data_handler.py:
    - Purpose: Responsible for fetching, storing, and processing historical market data.
    - Classes:
        - DataFetcher:
            - Attributes:
                - source_type: String, specifies the data source ('yfinance', 'csv', etc.).
            - Methods:
                - __init__(self, source_type='yfinance'): Constructor, sets the data source.
                - fetch_historical_data(self, symbol: str, start_date: str, end_date: str) -> dict: Fetches historical data and returns a dictionary where keys are timestamps and values are dictionaries with fields like `open`, `high`, `low`, `close`, `volume`.
        - DataStorage:
            - Attributes:
                - data: Dictionary, stores the fetched historical data.
            - Methods:
                - __init__(self): Constructor.
                - store_data(self, symbol: str, data: dict): Stores the fetched data for a given symbol.
                - get_data(self, symbol: str, time_frame: int = 0) -> list: Returns a list of data points for a given symbol and timeframe.

2. strategy.py:
    - Purpose: Encapsulates the trading strategy logic.
    - Classes:
        - TradingStrategy (Abstract Base Class):
            - Attributes:
                - name: String, the name of the strategy.
            - Methods:
                - __init__(self, name: str): Constructor.
                - should_buy(self, data_point: dict) -> bool: Abstract method, returns True if the strategy suggests a buy.
                - should_sell(self, data_point: dict) -> bool: Abstract method, returns True if the strategy suggests a sell.
                - update_historical_data(self, data: list): Abstract method, updates the historical data used by the strategy
        - MovingAverageStrategy:
            - Attributes:
                - short_window: Integer, the short window size for the moving average.
                - long_window: Integer, the long window size for the moving average.
                - historical_data: A list to store historical data
                - prev_short_ma: Stores the previous short moving average
                - prev_long_ma: Stores the previous long moving average
            - Methods:
                - __init__(self, short_window: int, long_window: int): Constructor.
                - should_buy(self, data_point: dict) -> bool: Implements the buy logic based on moving averages.
                - should_sell(self, data_point: dict) -> bool: Implements the sell logic based on moving averages.
                - calculate_moving_average(self, data: list, window: int) -> float: Calculates the moving average for a given data list.
                - update_historical_data(self, data: list): Updates the historical data used by the strategy.

3. broker.py:
    - Purpose: Simulates the execution of trades.
    - Classes:
        - Broker:
            - Attributes:
                - balance: Float, current balance of the broker.
                - portfolio: Dictionary, stores the current assets and their amounts.
                - transaction_history: A list of dictionaries representing transactions.
            - Methods:
                - __init__(self, initial_balance: float): Constructor.
                - execute_trade(self, trade_type: str, symbol: str, price: float, volume: float) -> bool: Simulates the execution of a trade, returns True if success, False if failed, logs the transaction in the `transaction_history`.
                - get_balance(self) -> float: Returns current balance.
                - get_portfolio(self) -> dict: Returns current portfolio.
                - get_transaction_history(self) -> list: Returns transaction history

4. backtester.py:
    - Purpose: Responsible for backtesting the trading strategy using historical data.
    - Classes:
        - Backtester:
            - Attributes:
                - broker: Broker object to execute simulated trades
            - Methods:
                - __init__(self, initial_balance: float): Constructor, creates an internal Broker instance.
                - run_backtest(self, strategy: TradingStrategy, data: list) -> dict: Simulates the backtest and returns a dictionary of stats.

5. main.py:
    - Purpose: The entry point of the application, sets up the backtest.
    - Details: Creates instances of DataFetcher, DataStorage, TradingStrategy, Broker, and Backtester, fetches data, sets the strategy, and runs the backtest, prints the results of the backtest.


Implementation Status:

- [x] data_handler.py: DataFetcher (with yfinance) and DataStorage are implemented and tested.
- [x] strategy.py: TradingStrategy (abstract) and MovingAverageStrategy are implemented.
- [x] broker.py: Broker class is implemented.
- [x] backtester.py: Backtester is implemented.
- [x] main.py: Main functionality is implemented

Problem Description:

The algorithmic trading simulator is now generating trades! The backtest results now show the initial balance, final balance, profit, number of trades, and the transaction history.

Debugging Steps:

1.  Verified data fetching and storage in `data_handler.py`. The data is fetched correctly.
2.  Debugged the `MovingAverageStrategy` to verify the moving average calculations, and `should_buy` and `should_sell` logic.
3.  Verified the broker's trade execution logic. The trades are only not being executed.
4.  Verified backtester logic, the backtester is iterating over the data, and calling the strategy methods, but no trades are being triggered
5.  Verified that historical data is being passed correctly to the strategy
6.  Verified the `calculate_moving_average` method is calculating the averages correctly, also fixed the issue of returning 0 when there isn't enough data
7.  Verified that previous moving averages are being updated and compared correctly
8.  Modified the `should_buy` and `should_sell` methods to check the *previous* short and long moving averages and compare them with the *current* ones to detect the cross. Removed `last_short_ma` and `last_long_ma` variables
9. Modified the `update_historical_data` method to initialize `prev_short_ma` and `prev_long_ma` using the *first* available data point, and then update it with the current moving averages.
10. Removed the initialization of `prev_short_ma` and `prev_long_ma` from the `update_historical_data` method, so the cross detection logic works correctly.

Current Issue:

The strategy is now generating trades as expected.

Next Steps:

The project is now working correctly.
